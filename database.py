# database.py
"""
Handles SQLite database operations for storing new cards generated by the chatbot.
"""
import sqlite3
import logging
import os
from typing import List, Tuple, Optional, Dict, Any

logger = logging.getLogger(__name__)

DATABASE_FILE = "chatbot_cards.db" # Store DB in project root for now

def get_db_connection() -> sqlite3.Connection:
    """Establishes a connection to the SQLite database."""
    conn = sqlite3.connect(DATABASE_FILE)
    # Return rows as dictionary-like objects (easier access by column name)
    conn.row_factory = sqlite3.Row
    return conn

def initialize_database():
    """Creates the necessary table if it doesn't exist."""
    logger.info(f"Initializing database '{DATABASE_FILE}'...")
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS new_cards (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    front TEXT NOT NULL,
                    back TEXT NOT NULL,
                    tags TEXT, -- Store tags as a space-separated string for simplicity
                    status TEXT NOT NULL DEFAULT 'pending', -- 'pending' or 'synced'
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            # Add an index for faster status lookups
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_status ON new_cards (status)")
            conn.commit()
            logger.info("Database table 'new_cards' initialized successfully.")
    except sqlite3.Error as e:
        logger.exception(f"Database initialization error: {e}")
        raise # Re-raise to signal critical failure during startup

def add_new_card_to_db(front: str, back: str, tags: List[str]) -> Optional[int]:
    """Adds a new card generated by the chatbot to the database with 'pending' status."""
    tags_str = " ".join(tags) # Store as space-separated string
    logger.info(f"Attempting to add card to DB: Front='{front[:30]}...', Status='pending'")
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO new_cards (front, back, tags, status) VALUES (?, ?, ?, ?)",
                (front, back, tags_str, 'pending')
            )
            conn.commit()
            new_id = cursor.lastrowid
            logger.info(f"Successfully added card to DB with ID: {new_id}")
            return new_id
    except sqlite3.Error as e:
        logger.exception(f"Error adding card to database: {e}")
        return None

def get_pending_cards() -> List[Dict[str, Any]]:
    """Retrieves all cards from the database with 'pending' status."""
    logger.info("Fetching pending cards from database...")
    cards = []
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, front, back, tags FROM new_cards WHERE status = ?", ('pending',))
            rows = cursor.fetchall()
            # Convert sqlite3.Row objects to dictionaries
            cards = [dict(row) for row in rows]
            logger.info(f"Fetched {len(cards)} pending cards.")
    except sqlite3.Error as e:
        logger.exception(f"Error fetching pending cards: {e}")
        # Return empty list on error
    return cards

def mark_cards_as_synced(card_ids: List[int]):
    """Updates the status of given card IDs to 'synced'."""
    if not card_ids:
        logger.info("No card IDs provided to mark as synced.")
        return False

    logger.info(f"Attempting to mark {len(card_ids)} cards as synced: {card_ids}")
    # Create placeholders for the query -> (?, ?, ?)
    placeholders = ', '.join('?' for _ in card_ids)
    sql = f"UPDATE new_cards SET status = 'synced' WHERE id IN ({placeholders})"

    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(sql, card_ids)
            conn.commit()
            rows_affected = cursor.rowcount
            logger.info(f"Marked {rows_affected} cards as synced in DB.")
            # Check if all requested IDs were actually updated (optional)
            if rows_affected != len(card_ids):
                 logger.warning(f"Attempted to sync {len(card_ids)} IDs, but only {rows_affected} rows were updated.")
            return True
    except sqlite3.Error as e:
        logger.exception(f"Error marking cards as synced: {e}")
        return False